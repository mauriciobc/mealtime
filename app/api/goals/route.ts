import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { logger } from '@/lib/monitoring/logger';
import { Prisma } from '@prisma/client';

// Placeholder for WeightGoal and Milestone interfaces if not centrally defined
// You should import these from a shared types definition if available
interface Milestone {
  id: string;
  goal_id: string;
  weight: number;
  date: string;
  notes?: string | null;
  created_at: string;
}

interface WeightGoal {
  id: string;
  cat_id: string;
  goal_name: string;
  target_weight: number;
  target_date: string | null;
  start_weight: number | null;
  unit: string;
  status: string;
  notes: string | null;
  created_by: string;
  created_at: string;
  updated_at: string;
  milestones: Milestone[];
  cat?: any; // Relação com cats
  createdBy?: any; // Relação com profiles
}

// Define the expected structure for a new goal, similar to WeightGoalWithMilestones but without ID for creation
// This is what the client sends, and what we validate.
interface NewGoalData {
  cat_id: string;
  goal_name: string;
  start_date: string;
  target_date: string;
  initial_weight: number;
  target_weight: number;
  unit: 'kg' | 'lbs';
  description?: string;
  // user_id will be extracted from header or session
}

// This would be your actual database model structure for a Goal
// It includes fields auto-generated by the DB like id, createdAt, updatedAt
interface WeightGoalDbRecord extends NewGoalData {
  id: string; // Or number, depending on your DB
  user_id: string;
  isArchived: boolean;
  achieved_date: string | null;
  outcome_notes?: string | null;
  // Milestones might be a separate table or a JSON field depending on your DB schema
  // For simplicity, let's assume milestones are handled separately or not created by default here
  // createdAt: Date;
  // updatedAt: Date;
}

export async function GET(request: NextRequest) {
  try {
    const authUserId = request.headers.get('X-User-ID');

    if (!authUserId) {
      logger.warn('[GET /api/goals] Authorization Error: Missing X-User-ID header.', { url: request.nextUrl.toString() });
      return NextResponse.json(
        { error: 'Not authorized - User ID header is missing' }, 
        { 
          status: 401,
          headers: {
            'Content-Type': 'application/json'
          }
        }
      );
    }

    logger.debug(`[GET /api/goals] Authenticated User ID: ${authUserId}`);

    try {
      const goals = await prisma.weight_goals.findMany({
        where: {
          cat: {
            owner_id: authUserId
          }
        },
        include: {
          milestones: true
        },
        orderBy: {
          target_date: 'desc',
        },
      });

      logger.info(`[GET /api/goals] Found ${goals.length} goals for user ${authUserId}`);
      return NextResponse.json(goals, {
        headers: {
          'Content-Type': 'application/json'
        }
      });

    } catch (error: any) {
      logger.logError(error, { 
        message: 'Error fetching weight goals', 
        userId: authUserId, 
        requestUrl: request.nextUrl.toString() 
      });
      return NextResponse.json(
        { error: 'An error occurred while fetching weight goals' }, 
        { 
          status: 500,
          headers: {
            'Content-Type': 'application/json'
          }
        }
      );
    }
  } catch (err: any) {
    logger.error('[GET /api/goals] Unhandled Exception', err);
    return NextResponse.json(
      { error: 'Internal server error', details: err?.message || err },
      {
        status: 500,
        headers: {
          'Content-Type': 'application/json'
        }
      }
    );
  }
}

export async function POST(request: Request) {
  try {
    const userId = request.headers.get('X-User-ID');

    if (!userId) {
      return NextResponse.json(
        { error: 'User not authenticated' }, 
        { 
          status: 401,
          headers: {
            'Content-Type': 'application/json'
          }
        }
      );
    }

    try {
      const body = await request.json();
      const {
        cat_id,
        goal_name,
        start_date,
        target_date,
        initial_weight,
        target_weight,
        unit,
        description,
      } = body as NewGoalData;

      // --- Basic Validation ---
      if (!cat_id || !goal_name || !start_date || !target_date || !initial_weight || !target_weight || !unit) {
        return NextResponse.json(
          { error: 'Missing required goal fields' }, 
          { 
            status: 400,
            headers: {
              'Content-Type': 'application/json'
            }
          }
        );
      }
      if (typeof initial_weight !== 'number' || typeof target_weight !== 'number' || initial_weight <= 0 || target_weight <= 0) {
        return NextResponse.json(
          { error: 'Weights must be positive numbers' }, 
          { 
            status: 400,
            headers: {
              'Content-Type': 'application/json'
            }
          }
        );
      }
      if (new Date(target_date) <= new Date(start_date)) {
        return NextResponse.json(
          { error: 'Target date must be after start date' }, 
          { 
            status: 400,
            headers: {
              'Content-Type': 'application/json'
            }
          }
        );
      }
      if (!['kg', 'lbs'].includes(unit)) {
        return NextResponse.json(
          { error: 'Invalid unit. Must be kg or lbs' }, 
          { 
            status: 400,
            headers: {
              'Content-Type': 'application/json'
            }
          }
        );
      }

      // --- Actual Database Interaction using Prisma ---
      const data: Prisma.weight_goalsCreateInput = {
        goal_name,
        target_weight: new Prisma.Decimal(target_weight),
        target_date: target_date ? new Date(target_date) : null,
        start_weight: initial_weight ? new Prisma.Decimal(initial_weight) : null,
        unit,
        status: "active",
        notes: description || null,
        cat: { connect: { id: cat_id } },
        createdBy: { connect: { id: userId } }
        // Não inclua milestones aqui, pois normalmente são criados separadamente
      };

      const newGoal = await prisma.weight_goals.create({
        data,
        include: {
          milestones: true
        }
      });

      return NextResponse.json(newGoal, { 
        status: 201,
        headers: {
          'Content-Type': 'application/json'
        }
      });

    } catch (error) {
      console.error('[API_GOALS_POST]', error);
      if (error instanceof SyntaxError) {
        return NextResponse.json(
          { error: 'Invalid request body' }, 
          { 
            status: 400,
            headers: {
              'Content-Type': 'application/json'
            }
          }
        );
      }
      return NextResponse.json(
        { error: 'Failed to create goal', details: error?.message || error }, 
        { 
          status: 500,
          headers: {
            'Content-Type': 'application/json'
          }
        }
      );
    }
  } catch (err: any) {
    logger.error('[POST /api/goals] Unhandled Exception', err);
    return NextResponse.json(
      { error: 'Internal server error', details: err?.message || err },
      {
        status: 500,
        headers: {
          'Content-Type': 'application/json'
        }
      }
    );
  }
}

// You might also want a GET handler to fetch goals, if not already present elsewhere.
// For example:
/*
export async function GET(request: Request) {
  const userId = request.headers.get('X-User-ID');
  const { searchParams } = new URL(request.url);
  const catId = searchParams.get('catId'); // Optional: filter by catId

  if (!userId) {
    return NextResponse.json({ error: 'User not authenticated' }, { status: 401 });
  }

  try {
    // --- Placeholder for Database Interaction ---
    // let goals;
    // if (catId) {
    //   goals = await db.goal.findMany({ where: { user_id: userId, cat_id: catId } });
    // } else {
    //   goals = await db.goal.findMany({ where: { user_id: userId } });
    // }
    // // Sort by start_date descending or as needed
    // goals.sort((a, b) => new Date(b.start_date).getTime() - new Date(a.start_date).getTime());
    // --- End of Placeholder ---
    
    // For now, returning empty array
    const goals = []; 

    return NextResponse.json(goals, { status: 200 });
  } catch (error) {
    console.error('[API_GOALS_GET]', error);
    return NextResponse.json({ error: 'Failed to fetch goals' }, { status: 500 });
  }
}
*/ 
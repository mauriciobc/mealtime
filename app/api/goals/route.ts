import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { logger } from '@/lib/monitoring/logger';

// Placeholder for WeightGoal and Milestone interfaces if not centrally defined
// You should import these from a shared types definition if available
interface Milestone {
  id: string;
  name: string;
  target_weight: number;
  target_date: string;
  description?: string;
}

interface WeightGoal {
  id: string;
  cat_id: string;
  goal_name: string;
  start_date: string;
  target_date: string;
  initial_weight: number;
  target_weight: number;
  unit: 'kg' | 'lbs';
  milestones: Milestone[];
  description?: string;
  isArchived?: boolean;
  achieved_date?: string | null;
  outcome_notes?: string;
  user_id?: string; // Assuming goals might be linked to a user directly or via cat
}

// Define the expected structure for a new goal, similar to WeightGoalWithMilestones but without ID for creation
// This is what the client sends, and what we validate.
interface NewGoalData {
  cat_id: string;
  goal_name: string;
  start_date: string; // ISO Date string
  target_date: string; // ISO Date string
  initial_weight: number;
  target_weight: number;
  unit: 'kg' | 'lbs';
  description?: string;
  // user_id will be extracted from header or session
}

// This would be your actual database model structure for a Goal
// It includes fields auto-generated by the DB like id, createdAt, updatedAt
interface WeightGoalDbRecord extends NewGoalData {
  id: string; // Or number, depending on your DB
  user_id: string;
  isArchived: boolean;
  achieved_date: string | null;
  outcome_notes?: string | null;
  // Milestones might be a separate table or a JSON field depending on your DB schema
  // For simplicity, let's assume milestones are handled separately or not created by default here
  // createdAt: Date;
  // updatedAt: Date;
}

export async function GET(request: NextRequest) {
  const authUserId = request.headers.get('X-User-ID');

  if (!authUserId) {
    logger.warn('[GET /api/goals] Authorization Error: Missing X-User-ID header.', { url: request.nextUrl.toString() });
    return NextResponse.json({ error: 'Not authorized - User ID header is missing' }, { status: 401 });
  }

  logger.debug(`[GET /api/goals] Authenticated User ID: ${authUserId}`);

  try {
    // TODO: Implement actual logic to fetch goals for the authenticated user.
    // This might involve: 
    // 1. Fetching cats associated with the user (if goals are per-cat and not directly linked to user).
    //    const userCats = await prisma.cats.findMany({ where: { owner_id: authUserId }, select: { id: true } });
    //    const catIds = userCats.map(cat => cat.id);
    // 2. Querying goals based on user ID or their cat IDs.
    //    Adjust the Prisma query according to your schema (e.g., weight_goals table).
    
    const goals: WeightGoal[] = await prisma.weight_goals.findMany({
      where: {
        // Example: If goals have a direct user_id field
        // user_id: authUserId,

        // Example: If goals are linked via cats owned by the user
        // cat: { owner_id: authUserId }

        // Example: If goals are linked to a household and user is part of household (more complex query)
        // For now, assuming goals might have a cat_id and cats have an owner_id.
        // This requires that your `weight_goals` table can be related back to `authUserId`.
        // This is a placeholder, update with your actual schema relationship!
        cat: {
            owner_id: authUserId 
            // OR, if your cats are linked to households and users to households:
            // household: {
            //   household_members: {
            //     some: { user_id: authUserId }
            //   }
            // }
        }
      },
      include: {
        // Include milestones if they are a separate related table and you want to nest them.
        // If milestones are a JSONB field, this might not be needed here.
        // weight_goal_milestones: true, // Adjust if your relation name is different
      },
      orderBy: {
        target_date: 'desc', // Example ordering
      },
    });

    // If your milestones are a separate table and included, you might need to map them
    // to match the WeightGoalWithMilestones interface used in the frontend.
    // const formattedGoals = goals.map(goal => ({
    //   ...goal,
    //   milestones: goal.weight_goal_milestones || [] 
    // }));

    logger.info(`[GET /api/goals] Found ${goals.length} goals for user ${authUserId}`);
    return NextResponse.json(goals); // Return formattedGoals if you transformed them

  } catch (error: any) {
    logger.logError(error, { 
      message: 'Error fetching weight goals', 
      userId: authUserId, 
      requestUrl: request.nextUrl.toString() 
    });
    return NextResponse.json({ error: 'An error occurred while fetching weight goals' }, { status: 500 });
  }
}

export async function POST(request: Request) {
  const userId = request.headers.get('X-User-ID');

  if (!userId) {
    return NextResponse.json({ error: 'User not authenticated' }, { status: 401 });
  }

  try {
    const body = await request.json();
    const {
      cat_id,
      goal_name,
      start_date,
      target_date,
      initial_weight,
      target_weight,
      unit,
      description,
    } = body as NewGoalData;

    // --- Basic Validation ---
    if (!cat_id || !goal_name || !start_date || !target_date || !initial_weight || !target_weight || !unit) {
      return NextResponse.json({ error: 'Missing required goal fields' }, { status: 400 });
    }
    if (typeof initial_weight !== 'number' || typeof target_weight !== 'number' || initial_weight <= 0 || target_weight <= 0) {
      return NextResponse.json({ error: 'Weights must be positive numbers' }, { status: 400 });
    }
    if (new Date(target_date) <= new Date(start_date)) {
      return NextResponse.json({ error: 'Target date must be after start date' }, { status: 400 });
    }
    if (!['kg', 'lbs'].includes(unit)) {
      return NextResponse.json({ error: 'Invalid unit. Must be kg or lbs' }, { status: 400 });
    }

    // --- Actual Database Interaction using Prisma ---
    const newGoalDataFromPrisma = await prisma.weight_goals.create({
      data: {
        created_by: userId, // Changed from user_id to match schema (relation createdBy)
        cat_id,
        goal_name: goal_name, // Added: Assumes 'goal_name' will be added to schema.prisma
        // start_date is not directly in schema, created_at will serve this purpose.
        target_date: target_date ? new Date(target_date) : null, // Handle optional target_date from schema
        start_weight: initial_weight, // Changed from initial_weight to match schema (start_weight Decimal?)
        target_weight, // Matches schema (target_weight Decimal)
        unit: unit, // Added: Assumes 'unit' will be added to schema.prisma (e.g., unit String)
        notes: description || null, // Changed from description to notes to match schema (notes String?)
        status: "active", // Changed from isArchived: false to match schema (status String)
      },
    });
    // --- End of Actual Database Interaction ---

    // Ensure the returned object matches what the frontend expects (WeightGoalWithMilestones)
    const responseGoal = { 
      id: newGoalDataFromPrisma.id,
      cat_id: newGoalDataFromPrisma.cat_id,
      goal_name: newGoalDataFromPrisma.goal_name, // Assuming goal_name is now in the DB record
      start_date: newGoalDataFromPrisma.created_at.toISOString(), // Use created_at for start_date
      target_date: newGoalDataFromPrisma.target_date ? newGoalDataFromPrisma.target_date.toISOString() : null,
      initial_weight: newGoalDataFromPrisma.start_weight ? Number(newGoalDataFromPrisma.start_weight) : 0, // Map start_weight back
      target_weight: Number(newGoalDataFromPrisma.target_weight),
      unit: newGoalDataFromPrisma.unit, // Assuming unit is now in the DB record
      description: newGoalDataFromPrisma.notes, // Map notes back to description
      isArchived: newGoalDataFromPrisma.status !== "active", // Map status back to isArchived
      achieved_date: null, // Default for new goals, schema does not have this directly. Potentially new field or derived.
      outcome_notes: null, // Default for new goals, schema does not have this directly.
      milestones: [] // Assuming new goals start with no milestones
    };

    return NextResponse.json(responseGoal, { status: 201 });

  } catch (error) {
    console.error('[API_GOALS_POST]', error);
    if (error instanceof SyntaxError) { // JSON parsing error
        return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
    }
    return NextResponse.json({ error: 'Failed to create goal' }, { status: 500 });
  }
}

// You might also want a GET handler to fetch goals, if not already present elsewhere.
// For example:
/*
export async function GET(request: Request) {
  const userId = request.headers.get('X-User-ID');
  const { searchParams } = new URL(request.url);
  const catId = searchParams.get('catId'); // Optional: filter by catId

  if (!userId) {
    return NextResponse.json({ error: 'User not authenticated' }, { status: 401 });
  }

  try {
    // --- Placeholder for Database Interaction ---
    // let goals;
    // if (catId) {
    //   goals = await db.goal.findMany({ where: { user_id: userId, cat_id: catId } });
    // } else {
    //   goals = await db.goal.findMany({ where: { user_id: userId } });
    // }
    // // Sort by start_date descending or as needed
    // goals.sort((a, b) => new Date(b.start_date).getTime() - new Date(a.start_date).getTime());
    // --- End of Placeholder ---
    
    // For now, returning empty array
    const goals = []; 

    return NextResponse.json(goals, { status: 200 });
  } catch (error) {
    console.error('[API_GOALS_GET]', error);
    return NextResponse.json({ error: 'Failed to fetch goals' }, { status: 500 });
  }
}
*/ 
#!/usr/bin/env ts-node

import { PrismaClient } from '@prisma/client';

// Configura√ß√µes de seguran√ßa para banco de dados
export interface DatabaseSafetyConfig {
  allowedEnvironments: string[];
  productionProtection: boolean;
  requireConfirmation: boolean;
  maxDeletionsPerRun: number;
  backupBeforeDeletion: boolean;
}

export const DEFAULT_SAFETY_CONFIG: DatabaseSafetyConfig = {
  allowedEnvironments: ['test', 'development'],
  productionProtection: true,
  requireConfirmation: process.env.TEST_SAFETY_CONFIRMATION !== 'false',
  maxDeletionsPerRun: parseInt(process.env.TEST_MAX_DELETIONS || '1000'),
  backupBeforeDeletion: process.env.TEST_SAFETY_BACKUP !== 'false',
};

// Classe para valida√ß√£o de seguran√ßa do banco
export class DatabaseSafetyGuard {
  private config: DatabaseSafetyConfig;
  private prisma: PrismaClient;
  private deletionCount: number = 0;

  constructor(prisma: PrismaClient, config: Partial<DatabaseSafetyConfig> = {}) {
    this.prisma = prisma;
    this.config = { ...DEFAULT_SAFETY_CONFIG, ...config };
  }

  // Verificar se o ambiente √© seguro para opera√ß√µes destrutivas
  async validateEnvironment(): Promise<{ safe: boolean; reason?: string }> {
    const currentEnv = process.env.NODE_ENV || 'development';
    const databaseUrl = process.env.DATABASE_URL || '';

    // Verificar ambiente
    if (!this.config.allowedEnvironments.includes(currentEnv)) {
      return {
        safe: false,
        reason: `Ambiente '${currentEnv}' n√£o √© permitido para opera√ß√µes destrutivas. Ambientes permitidos: ${this.config.allowedEnvironments.join(', ')}`
      };
    }

    // Verificar se √© banco de produ√ß√£o
    if (this.config.productionProtection) {
      const isProduction = await this.isProductionDatabase(databaseUrl);
      if (isProduction) {
        return {
          safe: false,
          reason: 'Opera√ß√£o bloqueada: Banco de dados de produ√ß√£o detectado'
        };
      }
    }

    // Verificar URL do banco
    if (this.containsProductionKeywords(databaseUrl)) {
      return {
        safe: false,
        reason: 'Opera√ß√£o bloqueada: URL do banco cont√©m palavras-chave de produ√ß√£o'
      };
    }

    return { safe: true };
  }

  // Verificar se √© banco de produ√ß√£o
  private async isProductionDatabase(databaseUrl: string): Promise<boolean> {
    const productionKeywords = [
      'prod', 'production', 'live', 'main', 'master',
      'supabase.co', 'heroku.com', 'aws.amazon.com',
      'database.ondigitalocean.com', 'clever-cloud.com'
    ];

    const urlLower = databaseUrl.toLowerCase();
    
    // Verificar keywords na URL
    for (const keyword of productionKeywords) {
      if (urlLower.includes(keyword)) {
        return true;
      }
    }

    // Verificar se o banco tem muitos dados (indicativo de produ√ß√£o)
    try {
      const userCount = await this.prisma.profiles.count();
      const catCount = await this.prisma.cats.count();
      
      // Se tem mais de 100 usu√°rios ou 50 gatos, provavelmente √© produ√ß√£o
      if (userCount > 100 || catCount > 50) {
        return true;
      }
    } catch (error) {
      // Se n√£o conseguir contar, assumir que √© produ√ß√£o por seguran√ßa
      return true;
    }

    return false;
  }

  // Verificar se URL cont√©m palavras-chave de produ√ß√£o
  private containsProductionKeywords(databaseUrl: string): boolean {
    const productionKeywords = [
      'prod', 'production', 'live', 'main', 'master',
      'supabase.co', 'heroku.com', 'aws.amazon.com',
      'database.ondigitalocean.com', 'clever-cloud.com'
    ];

    const urlLower = databaseUrl.toLowerCase();
    return productionKeywords.some(keyword => urlLower.includes(keyword));
  }

  // Validar opera√ß√£o de dele√ß√£o
  async validateDeletion(operation: string, count?: number): Promise<{ safe: boolean; reason?: string }> {
    // Verificar ambiente
    const envValidation = await this.validateEnvironment();
    if (!envValidation.safe) {
      return envValidation;
    }

    // Verificar limite de dele√ß√µes
    const estimatedCount = count || 1;
    if (this.deletionCount + estimatedCount > this.config.maxDeletionsPerRun) {
      return {
        safe: false,
        reason: `Limite de dele√ß√µes excedido: ${this.deletionCount + estimatedCount}/${this.config.maxDeletionsPerRun}`
      };
    }

    // Verificar se precisa de confirma√ß√£o
    if (this.config.requireConfirmation) {
      const confirmed = await this.requestConfirmation(operation, estimatedCount);
      if (!confirmed) {
        return {
          safe: false,
          reason: 'Opera√ß√£o cancelada pelo usu√°rio'
        };
      }
    }

    this.deletionCount += estimatedCount;
    return { safe: true };
  }

  // Solicitar confirma√ß√£o do usu√°rio
  private async requestConfirmation(operation: string, count: number): Promise<boolean> {
    const readline = require('readline');
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    console.log(`\n‚ö†Ô∏è  ATEN√á√ÉO: Opera√ß√£o destrutiva detectada!`);
    console.log(`   Opera√ß√£o: ${operation}`);
    console.log(`   Registros afetados: ~${count}`);
    console.log(`   Ambiente: ${process.env.NODE_ENV || 'development'}`);
    console.log(`   Database URL: ${this.maskDatabaseUrl(process.env.DATABASE_URL || '')}`);
    
    return new Promise((resolve) => {
      rl.question('\nü§î Confirma esta opera√ß√£o? (digite "SIM" para confirmar): ', (answer: string) => {
        rl.close();
        resolve(answer.toUpperCase() === 'SIM');
      });
    });
  }

  // Mascarar URL do banco para seguran√ßa
  private maskDatabaseUrl(url: string): string {
    if (!url) return 'n√£o definida';
    
    try {
      const urlObj = new URL(url);
      const maskedPassword = '*'.repeat(urlObj.password?.length || 0);
      return url.replace(urlObj.password || '', maskedPassword);
    } catch {
      return 'URL inv√°lida';
    }
  }

  // Fazer backup antes de dele√ß√£o
  async backupIfRequired(): Promise<Record<string, any[]> | null> {
    if (!this.config.backupBeforeDeletion) {
      return null;
    }

    try {
      console.log('üíæ Fazendo backup antes da opera√ß√£o...');
      
      const backup: Record<string, any[]> = {};
      backup.profiles = await this.prisma.profiles.findMany();
      backup.households = await this.prisma.households.findMany();
      backup.cats = await this.prisma.cats.findMany();
      backup.feeding_logs = await this.prisma.feeding_logs.findMany();
      backup.cat_weight_logs = await this.prisma.cat_weight_logs.findMany();
      
      console.log(`   ‚úÖ Backup criado: ${Object.values(backup).reduce((sum, arr) => sum + arr.length, 0)} registros`);
      return backup;
    } catch (error) {
      console.error('‚ùå Erro ao criar backup:', error);
      return null;
    }
  }

  // Restaurar backup
  async restoreBackup(backup: Record<string, any[]>): Promise<void> {
    if (!backup) return;

    try {
      console.log('üîÑ Restaurando backup...');
      
      // Limpar dados atuais
      await this.prisma.cat_weight_logs.deleteMany();
      await this.prisma.feeding_logs.deleteMany();
      await this.prisma.cats.deleteMany();
      await this.prisma.households.deleteMany();
      await this.prisma.profiles.deleteMany();
      
      // Restaurar dados
      if (backup.households.length > 0) {
        await this.prisma.households.createMany({ data: backup.households });
      }
      if (backup.profiles.length > 0) {
        await this.prisma.profiles.createMany({ data: backup.profiles });
      }
      if (backup.cats.length > 0) {
        await this.prisma.cats.createMany({ data: backup.cats });
      }
      if (backup.feeding_logs.length > 0) {
        await this.prisma.feeding_logs.createMany({ data: backup.feeding_logs });
      }
      if (backup.cat_weight_logs.length > 0) {
        await this.prisma.cat_weight_logs.createMany({ data: backup.cat_weight_logs });
      }
      
      console.log('‚úÖ Backup restaurado com sucesso');
    } catch (error) {
      console.error('‚ùå Erro ao restaurar backup:', error);
      throw error;
    }
  }

  // Obter estat√≠sticas de seguran√ßa
  getSafetyStats(): { deletionCount: number; maxDeletions: number; environment: string } {
    return {
      deletionCount: this.deletionCount,
      maxDeletions: this.config.maxDeletionsPerRun,
      environment: process.env.NODE_ENV || 'development'
    };
  }

  // Resetar contador de dele√ß√µes
  resetDeletionCount(): void {
    this.deletionCount = 0;
  }
}

// Fun√ß√£o utilit√°ria para criar guarda de seguran√ßa
export function createDatabaseSafetyGuard(
  prisma: PrismaClient, 
  config: Partial<DatabaseSafetyConfig> = {}
): DatabaseSafetyGuard {
  return new DatabaseSafetyGuard(prisma, config);
}

// Fun√ß√£o para validar ambiente antes de qualquer opera√ß√£o destrutiva
export async function validateDestructiveOperation(
  prisma: PrismaClient,
  operation: string,
  config: Partial<DatabaseSafetyConfig> = {}
): Promise<{ safe: boolean; guard: DatabaseSafetyGuard; reason?: string }> {
  const guard = createDatabaseSafetyGuard(prisma, config);
  const validation = await guard.validateEnvironment();
  
  if (!validation.safe) {
    return { safe: false, guard, reason: validation.reason };
  }

  const deletionValidation = await guard.validateDeletion(operation);
  return { safe: deletionValidation.safe, guard, reason: deletionValidation.reason };
}

// Exportar configura√ß√µes padr√£o
export default {
  DatabaseSafetyGuard,
  createDatabaseSafetyGuard,
  validateDestructiveOperation,
  DEFAULT_SAFETY_CONFIG
}; 